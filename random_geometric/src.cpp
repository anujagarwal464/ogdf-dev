/*
 * Random Geometric Graphs 
 * Mathew D. Penrose, University of Bath, UK
 * http://www.ma.hw.ac.uk/epi/edinburgh11/talks/Penrose.pdf
 *
 * Wiki: http://en.wikipedia.org/wiki/Random_geometric_graph
 *
 * A random geometric graph is a random undirected graph drawn
 * on a bounded region. It is generated by
 *  1. Placing vertices at random uniformly and independently on the region
 *  2. Connecting two vertices, u, v if and only if the distance between them
 *     is at most a threshold r, i.e. d (u, v) â‰¤ r.
 */

#include <iostream>
#include <cmath>
#include <random>

#include <ogdf/basic/Graph.h>
#include <ogdf/basic/NodeArray.h>
#include <ogdf/basic/geometry.h>

using std::minstd_rand;
using std::uniform_int_distribution;
using std::uniform_real_distribution;
using namespace ogdf;

//! Creates a Random Geometeric Graph by laying out nodes in a unit n-cube.
/**
 * @param G is assigned the generated graph.
 * @param n is the number of nodes of the generated graph.
 * @param threshold is threshold radius.
 * @dimension is the dimension of n-cube.
 */
void randomGeometricCubeGraph(Graph &G, int n, double threshold, int dimension=2) {
	OGDF_ASSERT(dimension >= 2);
	
	G.clear();
	if (n == 0) return;

	minstd_rand rng(randomSeed());
	uniform_real_distribution<> dist(0, 1);

	NodeArray<Array<double>> cord(G, Array<double>(dimension));

	// adding n nodes to graph
	for (int i = 0; i < n; i++) {
		G.newNode();
	}

	// setting random points in the n-cube
	for (node v : G.nodes) {
		for (int i = 0; i < dimension; i++){
			cord[v][i] = dist(rng);
		}
	}

	for (node v : G.nodes) {
		for (node w = v->succ(); w; w = w->succ()) {
			double distance = 0.0;
			for (int i = 0; i < dimension; i++) {
				distance += (cord[v][i] - cord[w][i])*(cord[v][i] - cord[w][i]);
			}
			distance = sqrt(distance);
			distance *= threshold;
			if (distance < (threshold + std::numeric_limits<double>::epsilon())) {
				G.newEdge(v, w);
			}
		}
	}

}


//! Creates a Random Geometeric Graph by laying out nodes in a torus.
/**
 * @param G is assigned the generated graph.
 * @param n is the number of nodes of the generated graph.
 * @param threshold is threshold radius.
 */
void randomGeometricTorusGraph(Graph &G, int n, double threshold) {
	G.clear();
	if (n == 0) return;

	minstd_rand rng(randomSeed());
	uniform_real_distribution<> dist(0, 1);
	NodeArray <double> cordx(G, 0.0);
	NodeArray <double> cordy(G, 0.0);

	// adding n nodes to graph
	for (int i = 0; i < n; i++) {
		G.newNode();
	}

	// setting random points in the torus
	for (node v : G.nodes) {
		cordx[v] = dist(rng);
		cordy[v] = dist(rng);
	}

	for (node v : G.nodes) {
		for (node w = v->succ(); w; w = w->succ()) {
			double dx = std::min(abs(cordx[v] - cordx[w]), 1 - abs(cordx[v] - cordx[w]));
			double dy = std::min(abs(cordy[v] - cordy[w]), 1 - abs(cordy[v] - cordy[w]));
			double distance = sqrt(dx*dx + dy*dy);
			distance *= threshold;
			if (distance < (threshold / 2 + std::numeric_limits<double>::epsilon())) {
				G.newEdge(v, w);
			}
		}
	}

}

int main(){
	//! TODO: tests
	Graph G;
	randomGeometricCubeGraph(G, 100, 10);
	randomGeometricCubeGraph(G, 100, 10, 4);
	randomGeometricTorusGraph(G, 100, 10);

	return 0;
}
